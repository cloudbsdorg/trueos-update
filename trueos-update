#!/bin/sh
# Script which performs updating services
############################################################################

# Exit with a error message
exit_err() {
        if [ -n "${LOGFILE}" ] ; then
           echo "ERROR: $*" >> ${LOGFILE}
        fi
        echo >&2 "ERROR: $*"
        exit 1
}

# Run-command, halt if command exits with non-0
rc_halt()
{
  CMD="$@"

  if [ -z "${CMD}" ] ; then
    exit_err "Error: missing argument in rc_halt()"
  fi

  ${CMD}
  STATUS=$?
  if [ ${STATUS} -ne 0 ] ; then
    exit_err "Error ${STATUS}: ${CMD}"
  fi
}

rc_nohalt()
{
  CMD="$@"

  if [ -z "${CMD}" ] ; then
    exit_err "Error: missing argument in rc_halt()"
  fi

  ${CMD}
  STATUS=$?
}

run_cmd_wtee()
{
  ((((${1} 2>&1 ; echo $? >&3 ) | tee -a ${2} >&4 ) 3>&1) | (read xs; exit $xs)) 4>&1
  return $?
}

# Set the program location
PROGDIR="/var/trueos-update" ; export PROGDIR

# Set the pub openssl key
SKEY="${PROGDIR}/conf/security.key" ; export SKEY

# How long before pkg times out
FETCH_TIMEOUT="600" ; export FETCH_TIMEOUT

# Start by sourcing /etc/profile
# This grabs any HTTP_ / FTP_ PROXY variables
. /etc/profile

# Set the default SYSTYPE
SYSTYPE="DESKTOP"
if [ -e "/etc/defaults/trueos-server" ] ; then
  SYSTYPE="SERVER"
fi

# Fix some issues with pkg trying to go non-interactive
ASSUME_ALWAYS_YES="YES"
export ASSUME_ALWAYS_YES

do_self_bootstrap() {
  # Only do this as root
  if [ `id -u` != "0" ] ; then return 0; fi

  # Start the updaters self-update protocol
  local fbsdmajor=$(uname -r | cut -d '-' -f 1 | cut -d '.' -f 1)
  local fbsdupdateurl="http://www.trueos.org/updates/pc-updater-${fbsdmajor}.txz"
  local dlfile=`mktemp /tmp/.pc-updater.XXXXXX`
  if [ $? -ne 0 ] ; then
    return 0
  fi
  echo -e "Boot-strapping updater...\c"

  # Fetch the updater
  fetch -m -o ${dlfile} ${fbsdupdateurl} >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then echo "FAILED Fetch" ; return 1; fi

  # Fetch the signature
  fetch -m -o ${dlfile}.sha1 ${fbsdupdateurl}.sha1 >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then echo "FAILED Fetch2" ; return 1; fi

  # Lets verify the signature of the file
  openssl dgst -sha1 -verify ${SKEY} \
	-signature ${dlfile}.sha1 \
        ${dlfile} >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then echo "FAILED signature" ; return 1; fi

  extractdir=`mktemp -d /tmp/pc-update-XXXXXX`
  if [ $? -ne 0 ] ; then echo "FAILED - mktemp" ; return 1; fi

  tar xvpf ${dlfile} -C $extractdir >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then echo "FAILED - extract" ; return 1; fi

  # Install it now
  make -C $extractdir install >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then echo "FAILED - install" ; return 1; fi

  if [ -n "$extractdir" -a "$extractdir" != "/" -a -d "$extractdir" ] ; then
    rm -rf $extractdir
  fi
  echo "OK"

  rm ${dlfile}.sha1 >/dev/null 2>/dev/null
  rm ${dlfile} >/dev/null 2>/dev/null

  return 0
}

# Check if we need to try a self-update
if [ -z "$DISABLE_UPDATE_BOOTSTRAP" -a -n "${1}" -a "${1}" != "doshutdownupdate" -a "$1" != "startupdate" ] ; then

  export DISABLE_UPDATE_BOOTSTRAP="YES"

  do_self_bootstrap

  # Run the original command now
  ${0} ${@}
  exit $?
fi

trueos_ETCCONF="/usr/local/etc/trueos.conf"
export trueos_ETCCONF

# Directory to store downloaded updates
DOWNLOADDIR="/usr/local/tmp"

# Get the system version we are checking for updates to
SYSVER="`uname -r | cut -d '-' -f 1-2`" ; export SYSVER

# Set the config location
UPDATECONF="${PROGDIR}/conf/sysupdate.conf"

# Set the system arch type
ARCH=`uname -m`

# Location for master IPFS files which list latest stable/unstable hashes
IPFS_HASHFILE_STABLE="https://www.trueos.org/updates/trueos-ipfs-stable"
IPFS_HASHFILE_UNSTABLE="https://www.trueos.org/updates/trueos-ipfs-unstable"

# Patchset Data
PATCHSERVER="`cat ${UPDATECONF} | grep '^UPDATESERVER:' | cut -d ' ' -f 2`"
PATCHSET="`cat ${UPDATECONF} | grep '^PATCHSET:' | cut -d ' ' -f 2`"
PATCHFILE="${PATCHSET}.upd"
PATCHURL="${PATCHSERVER}/${PATCHFILE}"
PATCHTMPDIR=`mktemp -d /tmp/.sysupdateXXXXXX`
PATCHTMPFILE="${PATCHTMPDIR}/sysupdate-${SYSVER}.upd"

MUSTAGEDIR="${DOWNLOADDIR}/update-stagedir"

# Enable ftp passive mode for file transfers
FTP_PASSIVE_MODE="YES" ; export FTP_PASSIVE_MODE

if [ ! -d "${DOWNLOADDIR}" ]; then mkdir -p ${DOWNLOADDIR}; fi

# Location for custom scripts for upgrades
UPDATEDOTD="/usr/local/etc/pcupdate.d"

# Trigger File for Tray Application
TRIGGERFILE="/tmp/.sysupdatetraytrigger"

DBDIR="/var/db/pc-updatemanager"
INSDIR="${DBDIR}/installed"
IGNDIR="${DBDIR}/ignored"

# PKG_CMD to use
PKG_CMD="/usr/local/sbin/pkg-static"

# Make sure we don't keep these from system environment
unset INJAIL PKG_FLAG

# Set pkg flags for which repo we want to use
PKG_TRUEOS_REPO="trueos-major"
PKG_BASE_REPO="trueos-base"

ISOTMP="/usr/local/tmp/trueos-update.iso"

# The default log file for output messages
LOGOUT="/var/log/pc-updatemanager.log"

# Return codes
PKGUPDATERTN=100
UPDATEOTHERRTN=125

# Files to overwrite in /etc with upgrades
ETC_DISTUPGRADE="./etc/rc ./etc/rc.shutdown ./etc/rc.devd ./etc/devd.conf ./etc/defaults/rc.conf ./etc/auto_master /etc/autofs ./etc/network.subr"

# Default OpenRC Services to enable
OPENRC_BOOT_SERV="abi adjkerntz bootmisc cron devd dumpon fsck hostid hostname localmount loopback modules motd network newsyslog nisdomain"
OPENRC_BOOT_SERV="${OPENRC_BOOT_SERV} root routing savecore staticroute swap syscons sysctl syslogd urandom zfs zvol "
OPENRC_DEFAULT_SERV="local netmount"
OPENRC_SHUTDOWN_SERV="savecache"
OPENRC_NONET_SERV="local"
export OPENRC_BOOT_SERV OPENRC_DEFAULT_SERV OPENRC_SHUTDOWN_SERV OPENRC_NONET_SERV

# Pkg does stuff now with ABIs and it prevents updating the database
export IGNORE_OSVERSION="YES"

######################################################################
# Done with config values
######################################################################

# Get the PACKAGE_SET to use for this pkgng repo
PACKAGE_SET="PRODUCTION"
_pkgChk="`sed -n 's/^PACKAGE_SET: //p' ${trueos_ETCCONF} 2>/dev/null | awk '{print $1}'`"
if [ -n "${_pkgChk}" ] ; then PACKAGE_SET="$_pkgChk" ; fi

AUTO_UPDATE="securitypkg"
_upChk="`sed -n 's/^AUTO_UPDATE: //p' ${trueos_ETCCONF} 2>/dev/null | awk '{print $1}'`"
if [ -n "${_upChk}" ] ; then AUTO_UPDATE="$_upChk" ; fi

CDN_TYPE="HTTP"
_cdnChk="`sed -n 's/^CDN_TYPE: //p' ${trueos_ETCCONF} 2>/dev/null | awk '{print $1}'`"
if [ -n "${_cdnChk}" ] ; then CDN_TYPE="$_cdnChk" ; fi

if [ "$CDN_TYPE" = "IPFS" ] ; then
  # If we succeed, lets bootstrap IPFS
  rc-update | grep -q ipfs-go
  if [ $? -ne 0 ] ; then
    rc-update add ipfs-go >/dev/null 2>/dev/null
    (service ipfs-go start >/dev/null 2>/dev/null) &
  fi

  # Set new default timeouts for pkg fetch
  if [ -e "/usr/local/etc/pkg.conf" ] ; then
    cat /usr/local/etc/pkg.conf | grep -q "FETCH_TIMEOUT"
    if [ $? -ne 0 ] ; then
      echo "FETCH_TIMEOUT: 360" >> /usr/local/etc/pkg.conf
    fi
  fi

fi

# Check the PACKAGE_SET variable
case $PACKAGE_SET in
  ENTERPRISE|PRODUCTION|EDGE|STABLE|UNSTABLE) ;;
  CUSTOM) # Using a custom package set?
          # Lets check that we have a URL provided
	  _urlChk="`sed -n 's/^PACKAGE_URL: //p' ${trueos_ETCCONF} 2>/dev/null | awk '{print $1}'`"
	  if [ -z "${_urlChk}" ] ; then
	     echo "Warning: PACKAGE_SET is CUSTOM, but no PACKAGE_URL set!"
	     echo "Reverting back to PRODUCTION repo..."
	     sleep 3
             CUSTOM_URL=""
	     PACKAGE_SET="PRODUCTION"
	  else
	     CUSTOM_URL="$_urlChk"
          fi
	  _urlChk="`sed -n 's/^CURSYS_PACKAGE_URL: //p' ${trueos_ETCCONF} 2>/dev/null | awk '{print $1}'`"
	  if [ -z "${_urlChk}" ] ; then
             CUSTOM_CURSYS_URL=""
	  else
	     CUSTOM_CURSYS_URL="$_urlChk"
          fi
          ;;
       *) echo "Warning: Invalid PACKAGE_SET!" 
          PACKAGE_SET="PRODUCTION" ;; 
esac

# Set the location for saving program state
STATEDIR="/var/db/pc-updatemanager"

# Function to download a file from remote using fetch
# Arg1 = Remote File URL
# Arg2 = Where to save file
# Arg3 = Number of attempts to make before failing
get_file() {

	_rf="${1}"
	_lf="${2}"
        _ftries=${3}
	if [ -z "$_ftries" ] ; then _ftries=3; fi

        # Get any proxy information
        . /etc/profile

	if [ -e "${_lf}" ] ; then 
		echo "Resuming download of: ${_lf}"
	fi

	if [ "$GUI_FETCH_PARSING" != "YES" -a -z "$PCFETCHGUI" ] ; then
		fetch -r -o "${_lf}" "${_rf}"
		_err=$?
	else
		echo "FETCH: ${_rf}"

		# Doing a front-end download, parse the output of fetch
		_eFile="/tmp/.fetch-exit.$$"
		fetch -s "${_rf}" > /tmp/.fetch-size.$$ 2>/dev/null
		_fSize=`cat /tmp/.fetch-size.$$ 2>/dev/null`
		_fSize="`expr ${_fSize} / 1024 2>/dev/null`"
		rm "/tmp/.fetch-size.$$" 2>/dev/null
		_time=1
		if [ -z "$_fSize" ] ; then _fSize=0; fi

		( fetch -r -o "${_lf}" "${_rf}" >/dev/null 2>/dev/null ; echo "$?" > ${_eFile} ) &
		FETCH_PID=`ps -auwwwx | grep -v grep | grep "fetch -r -o ${_lf}" | awk '{print $2}'`
		while : 
		do
			if [ -e "${_lf}" ] ; then
				_dSize=`du -k ${_lf} | tr -d '\t' | cut -d '/' -f 1`
				if [ $(is_num "$_dSize") ] ; then
					if [ ${_fSize} -lt ${_dSize} ] ; then _dSize="$_fSize" ; fi
					_kbs=`expr ${_dSize} \/ $_time`
					echo "SIZE: ${_fSize} DOWNLOADED: ${_dSize} SPEED: ${_kbs} KB/s"
				fi
			fi

			# Make sure download isn't finished
			ps -p $FETCH_PID >/dev/null 2>/dev/null
			if [ "$?" != "0" ] ; then break ; fi
			sleep 2
			_time=`expr $_time + 2`
		done

		_err="`cat ${_eFile} 2>/dev/null`"
		if [ -z "$_err" ] ; then _err="0"; fi
                rm ${_eFile} 2>/dev/null
		if [ "$_err" = "0" ]; then echo "FETCHDONE" ; fi
		unset FETCH_PID
	fi

	echo ""
	if [ $_err -ne 0 -a $_ftries -gt 0 ] ; then
		sleep 30
		_ftries=`expr $_ftries - 1`

		# Remove the local file if we failed
		if [ -e "${_lf}" ]; then rm "${_lf}"; fi

		get_file "${_rf}" "${_lf}" $_ftries
		_err=$?
	fi
	return $_err
}

# Run-command, halt if command exits with non-0
rc_halt_cleanup()
{
  CMD="$@"

  if [ -z "${CMD}" ] ; then
    exit_err "Error: missing argument in rc_halt_cleanup()"
  fi
  echo "Running: $CMD" >> ${LOGOUT}

  ${CMD}
  STATUS=$?
  if [ ${STATUS} -ne 0 ] ; then
    sync ; sleep 2
    # Cleanup the boot-environment
    umount -f $STAGEMNT/dev 2>/dev/null >/dev/null
    umount -f $STAGEMNT 2>/dev/null >/dev/null
    beadm destroy -F $STAGEBE
    echo "Error ${STATUS}: ${CMD}" >> ${LOGOUT}
    exit_err "Error ${STATUS}: ${CMD}"
  fi
}

show_usage() {
        echo "pc-updatemanager: Usage
----
  branches 		- List available system branches
  chbranch <tag>	- Change to new system branch
  check			- Check for system updates
  showeol               - Show end of life (support) date for this release
  install <tag>,<tag2>	- Install system updates
  pkgcheck		- Check for updates to packages
  pkgupdate [-f]	- Install packages updates (-f to force)
  syncconf		- Update PC-BSD pkg configuration
  confcheck		- Check PC-BSD pkg configuration
  cron                  - Perform delayed check for system and pkg updates.
"

	exit 1
}

echo_log()
{
   echo "$@"
   echo "$@" >> ${LOGOUT}
}

get_latest_ipfs_hash()
{
  PSET="PRODUCTION"
  _pkgChk="`sed -n 's/^PACKAGE_SET: //p' ${trueos_ETCCONF} 2>/dev/null | awk '{print $1}'`"
  if [ -n "${_pkgChk}" ] ; then PSET="$_pkgChk" ; fi
  case $PSET in
	    UNSTABLE) _fUrl="${IPFS_HASHFILE_UNSTABLE}" ;;
		*) _fUrl="${IPFS_HASHFILE_STABLE}" ;;
  esac
  fetch -o /tmp/.tipfs.$$ ${_fUrl} >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then
    rm /tmp/.tipfs.$$
    echo "ERROR: Could not fetch IPFS hashes!"
    exit 1
  fi
  IPFS_HASH=`cat /tmp/.tipfs.$$ | sort -r | head -n 1 | awk '{print $2}'`
  rm /tmp/.tipfs.$$

  if [ -z "$IPFS_HASH" ] ; then
    echo "ERROR: Could not fetch IPFS hashes!"
    exit 1
  fi
  return 0
}

setup_pkgng_conf() {

  # Create the repos directory
  if [ ! -d "/usr/local/etc/pkg/repos" ] ; then
    mkdir -p /usr/local/etc/pkg/repos
  fi

  # Disable the FreeBSD repo
  if [ ! -e "/usr/local/etc/pkg/repos/FreeBSD.conf" ] ; then
    echo "FreeBSD: { enabled: no }" > /usr/local/etc/pkg/repos/FreeBSD.conf
  fi

  # See if we need to adjust trueos.conf repo file
  if [ ! -e "/usr/local/etc/pkg/repos/trueos.conf.dist" ];then
     echo "WARNING: Missing /usr/local/etc/pkg/repos/trueos.conf.dist"
     status="1"
     return 1
  fi

  # Remove old pkg conf
  if [ -e "/usr/local/etc/pkg/repos/trueos.conf" ] ; then
    rm /usr/local/etc/pkg/repos/trueos.conf
  fi

  if [ "$CDN_TYPE" = "IPFS" ] ; then
	  if [ ! -e '/var/db/trueos-pkg-ipfs' ] ; then
		echo "No stored IPFS hash... Fetching latest from master site..."
		get_latest_ipfs_hash
		echo "$IPFS_HASH" > /var/db/trueos-pkg-ipfs
	  fi
	  ipfshash=`cat /var/db/trueos-pkg-ipfs`
	  PACKAGE_SET="CUSTOM"
	  CUSTOM_URL="http://127.0.0.1:8080/ipfs/${ipfshash}/${ARCH}"

	  # Make sure the trueos IPFS daemon is running
	  service ipfs-go status >/dev/null 2>/dev/null
	  if [ $? -ne 0 ] ; then
		  (service ipfs-go start >/dev/null 2>/dev/null ) &
		  sleep 2
	  fi
	  # Make sure the daemon is set to run at startup
	  rc-update show default | grep -q ipfs-go
	  if [ $? -ne 0 ] ; then
		rc-update add ipfs-go default #>/dev/null 2>dev/null
	  fi
  fi

  ARCH=`uname -m`
  PKGVER="master"

  # If using the UNSTABLE package set, set the right path
  case $PACKAGE_SET in
   UNSTABLE|EDGE) PKGVER="unstable" ;;
          *) ;;
  esac

  # Now create standard trueos.conf file
  if [ "$PACKAGE_SET" = "CUSTOM" -a -n "$CUSTOM_URL" ] ; then
     # Change %VERSION% / %ARCH% keys
     CUSTOM_URL=`echo $CUSTOM_URL | sed "s|%VERSION%|$PKGVER|g" | sed "s|%ARCH%|$ARCH|g" | sed 's|/$||g'`
     cat << EOF >/usr/local/etc/pkg/repos/trueos.conf
trueos-major: {
               url: "$CUSTOM_URL",
               signature_type: "fingerprints",
               fingerprints: "/usr/local/etc/pkg/fingerprints/trueos",
               enabled: true
              }
EOF
     # Now do the same for base packages
     CUSTOM_URL=`echo $CUSTOM_URL | sed "s|%VERSION%|$PKGVER|g" | sed "s|%ARCH%|$ARCH|g" | sed 's|/$||g'`
     cat << EOF >/usr/local/etc/pkg/repos/trueos-base.conf
trueos-base: {
               url: "${CUSTOM_URL}-base",
               signature_type: "fingerprints",
               fingerprints: "/usr/local/etc/pkg/fingerprints/trueos",
               enabled: true
              }
EOF
  else
    sed_pkg_repo_file_http
  fi
}

sed_pkg_repo_file_http() {
  cat /usr/local/etc/pkg/repos/trueos.conf.dist \
	| sed "s|trueos: |trueos-major: |g" \
	| sed "s|%VERSION%|$PKGVER|g" \
	| sed "s|%ARCH%|$ARCH|g" > /usr/local/etc/pkg/repos/trueos.conf

  cat /usr/local/etc/pkg/repos/trueos.conf.dist \
	| sed "s|trueos: |trueos-base: |g" \
	| sed "s|%VERSION%|$PKGVER|g" \
	| sed "s|%ARCH%|${ARCH}-base|g" > /usr/local/etc/pkg/repos/trueos-base.conf
}

get_update_file() {

  # Now fetch the update file
  get_file "${PATCHURL}" "${PATCHTMPFILE}" 1 >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE} 2>/dev/null
     is_net_up
     if [ $? -eq 0 ] ; then
       echo "No updates available for $SYSVER!" ; exit 0
     else
       exit_err "Could not contact update server!"
     fi
  fi

  # Now fetch the update file signature
  get_file "${PATCHURL}.sha1" "${PATCHTMPFILE}.sha1" 1 >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE}.sha1 2>/dev/null
     is_net_up
     if [ $? -eq 0 ] ; then 
       echo "No updates available for $SYSVER!" ; exit 0
     else
       echo_log "Could not contact update server!"
       exit_err "Could not contact update server!"
     fi
  fi

  # Lets verify the signature of the file
  openssl dgst -sha1 -verify ${SKEY} \
	-signature ${PATCHTMPFILE}.sha1 \
        ${PATCHTMPFILE} >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE} 2>/dev/null
     rm ${PATCHTMPFILE}.sha1 2>/dev/null
     echo_log "Update file failed verification..."
     exit_err "Update file failed verification..."
  fi

  # Done with the signature we can discard
  rm ${PATCHTMPFILE}.sha1

}

do_branch() {
  up="$1"

  # Setup our variable to catch if we have a bad branch
  BRANCHFOUND="0"

  while read line
  do
     echo $line | grep -q "^BRANCHES:"
     if [ $? -eq 0 ] ; then
	for i in `echo $line | cut -d ':' -f 2 | sed 's|,| |g'`
	do
	  if [ "$i" != "$up" ] ; then continue ;fi
	  if [ "`uname -r | cut -d '-' -f 1-2`" = "$up" ] ; then
	     echo "You are already on this branch!"
             BRANCHFOUND="1"
	     continue;
	  fi
          update_world_and_pkgs "$up"
          BRANCHFOUND="1"
	  break
	done
     fi
  done < ${PATCHTMPFILE}

  # If no patches
  if [ "${BRANCHFOUND}" = "0" ]; then
     # No available updates
     echo "Unknown branch ${1}"
  fi

  rm ${PATCHTMPFILE}

};

list_branches() {
  # Setup our variable, we have no branches so far
  BRANCHFOUND="0" 

  CURMAJOR="$(uname -r | cut -d '-' -f 1 |  cut -d '.' -f 1)"
  CURMINOR="$(uname -r | cut -d '-' -f 1 |  cut -d '.' -f 2)"

  while read line
  do
     echo $line | grep -q "^BRANCHES:"
     if [ $? -ne 0 ] ; then continue ; fi

     echo "Available branches:"
     echo "* = Current Branch"
     echo "----------------------------------"
     echo $line | cut -d ':' -f 2 | sed 's|,|\
|g' | while read branch
     do
       MAJOR="$(echo $branch | cut -d '-' -f 1 |  cut -d '.' -f 1)"
       MINOR="$(echo $branch | cut -d '-' -f 1 |  cut -d '.' -f 2)"

       # Filter out old versions
       if [ $CURMAJOR -gt $MAJOR ] ; then continue ; fi
       if [ $CURMAJOR -eq $MAJOR -a $CURMINOR -gt $MINOR ] ; then continue ; fi

       if [ "`uname -r | cut -d '-' -f 1-2`" = "$branch" ] ; then
         echo "$branch *"
       else
	 echo "$branch"
       fi
     done
     echo ""
     echo "To change branches run: ${0} chbranch <branch>"
     BRANCHFOUND="1"
     break
  done < ${PATCHTMPFILE}

  # If no patches
  if [ "${BRANCHFOUND}" = "0" ]; then
     # No available updates
     echo "No branches currently available!"
  fi

  rm ${PATCHTMPFILE}

};

do_check() {
  PATCHFOUND="0"

  while read line
  do
     echo $line | grep -q "^MAJOR:"
     if [ $? -eq 0 ] ; then
        parse_mu_update_line "$line"
        continue
     fi
     echo $line | grep -q "^SA:"
     if [ $? -eq 0 ] ; then
        parse_sa_update_line "$line"
        continue
     fi
     echo $line | grep -q "^EOL:"
     if [ $? -eq 0 ] ; then
        parse_eol_line "$line"
        continue
     fi
  done < ${PATCHTMPFILE}

  # If no patches
  if [ "${PATCHFOUND}" = "0" ]; then
     # No available updates
     echo "Your system is up to date!"
     if [ -e "/usr/local/bin/pc-systemflag" ]; then
       pc-systemflag SYSUPDATE SUCCESS #set the system flag that system is up to date
     fi
     rm ${PATCHTMPFILE}
     return 0
  fi

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag SYSUPDATE UPDATE #set the system flag that system updates are available
  fi
  rm ${PATCHTMPFILE}

  # Other updates
  return $UPDATEOTHERRTN
};

do_eol_display()
{
while read line
  do     
     echo $line | grep -q "^EOL:"
     if [ $? -eq 0 ] ; then
        parse_eol_line "$line"
        continue
     fi
  done < ${PATCHTMPFILE}

}

parse_eol_line()
{
   local line="$1"

   # Grab the values
   local sysEOLVer=`echo $line | cut -d ':' -f 2`
   local sysUpEOL=`echo $line | cut -d ':' -f 3`
   local curEpoc=`date +%s`
   local EOLdays=$(expr  \( ${sysUpEOL} - ${curEpoc} \) / \( 60 \* 60 \* 24 \) )

   if [ "$SYSVER" != "$sysEOLVer" ] ; then return; fi

   echo ""
   if [ $sysUpEOL -lt $curEpoc ] ; then
     echo "*WARNING* End of Life *WARNING*"
     echo "-----------------------------------"
     echo "This version of PC-BSD / TrueOS has passed its EOL date of:"
     echo "`date -j -r $sysUpEOL`"
     echo "You are strongly encouraged to upgrade your system!"
     echo "-----------------------------------"
   else
     echo "End of Life Notice"
     echo "-----------------------------------"
     echo "This version of PC-BSD / TrueOS has an EOL date of:"
     echo "`date -j -r $sysUpEOL`"
     echo "End of support (in days): $EOLdays"
     echo "-----------------------------------"
     echo ""
   fi
}

parse_mu_update_line()
{
   local line="$1"

   # Check if this is a major update we can install
   local sysUpOVer=`echo $line | cut -d ':' -f 2`
   local sysUpNVer=`echo $line | cut -d ':' -f 3`

   # Is this an update for our version?
   if [ "$SYSVER" != "$sysUpOVer" ] ; then return; fi

   if [ $PATCHFOUND -eq 0 ] ; then
      echo ""
      echo "The following updates are available:"
      echo "------------------------------------"
   fi
   echo "NAME: System Update to ${sysUpNVer}" 
   echo "TYPE: SYSTEMUPDATE" 
   echo "TAG: fbsd-${sysUpNVer}"
   echo "VERSION: ${sysUpNVer}" 
   echo ""
   echo "To install: \"pc-updatemanager install fbsd-${sysUpNVer}\""
   echo ""
   echo ""

   PATCHFOUND="`expr ${PATCHFOUND} + 1`" 
   HAVEMAJORUPDATE="YES"
}

parse_sa_update_line()
{
   local line="$1"

   # Check if this is an update we can install
   local saVer=`echo $line | cut -d ':' -f 2`
   local saArch=`echo $line | cut -d ':' -f 3`
   local saType=`echo $line | cut -d ':' -f 4`
   local saIdent="`echo $line | cut -d ':' -f 5`"

   # For this version?
   if [ "$SYSVER" != "$saVer" ] ; then return ; fi

   # For this system arch?
   if [ "$ARCH" != "$saArch" -a "$saArch" != "noarch" ] ; then return ; fi

   # For this system type?
   if [ "$SYSTYPE" != "$saType" -a "$saType" != "both" ] ; then return ; fi

   # Already installed?
   if [ -e "${INSDIR}/${SYSVER}/$saIdent" ] ; then return ; fi

   if [ $PATCHFOUND -eq 0 ] ; then
      echo ""
      echo "The following updates are available:"
      echo "------------------------------------"
   fi
   local saDesc="`echo $line | cut -d ':' -f 6`"
   local saSize=`echo $line | cut -d ':' -f 8`
   local saDetail="`echo $line | cut -d ':' -f 10`"
   local saDate="`echo $line | cut -d ':' -f 11`"

   echo "NAME: ${saDesc}" 
   echo "TYPE: PATCH" 
   echo "TAG: ${saIdent}"
   echo "DETAILS: ${saDetail}"
   echo "DATE: ${saDate}"
   echo "SIZE: ${saSize}Mb" 
   echo " "
   echo "To install: \"pc-updatemanager install ${saIdent}\""
   echo " "

   PATCHFOUND="`expr ${PATCHFOUND} + 1`" 
}

start_trueos_patch() {
  local up="$1"
  local saIdent=""
  local saVer=""
  local saArch=""
  local saPlat=""
  local saUrl=""
  local saDesc=""
  local saCsum=""
  local patchLine=""
  if [ -e "${INSDIR}/${SYSVER}/${up}" ]; then 
     rm ${PATCHTMPFILE}
     exit_err "Patch $up already installed!"
  fi

  while read line
  do
    echo $line | grep -q "^SA:"
    if [ $? -ne 0 ] ; then continue; fi
    saIdent="`echo $line | cut -d ':' -f 5`"
    # Look for the right stand-alone update
    if [ "$saIdent" != "$up" ] ; then continue ; fi
    saVer=`echo $line | cut -d ':' -f 2`
    saArch=`echo $line | cut -d ':' -f 3`
    saType=`echo $line | cut -d ':' -f 4`
    # Does this update apply to this system arch?
    if [ "$saArch" != "$ARCH" -a "$saArch" != "noarch" ] ; then 
       rm ${PATCHTMPFILE}
       exit_err "Patch $up is not for this system arch type!"
    fi
    # For this version?
    if [ "$saVer" != "$SYSVER" ] ; then 
       rm ${PATCHTMPFILE}
       exit_err "Patch $up is not for this system version!"
    fi

    # For this system type?
    if [ "$SYSTYPE" != "$saType" -a "$saType" != "both" ] ; then
       rm ${PATCHTMPFILE}
       exit_err "Patch $up is not for this system type!"
    fi

    # Got here? We have a patch ready to go
    patchLine="$line"
    break
  done < ${PATCHTMPFILE}

  # Did we find the patch?
  if [ -z "$patchLine" ] ; then 
     rm ${PATCHTMPFILE}
     exit_err "Patch $up not found!"
  fi

  # Get the patch details
  saVer=`echo $patchLine | cut -d ':' -f 2`
  saArch=`echo $patchLine | cut -d ':' -f 3`
  saPlat=`echo $patchLine | cut -d ':' -f 4`
  saIdent="`echo $patchLine | cut -d ':' -f 5`"
  saDesc="`echo $patchLine | cut -d ':' -f 6`"
  saUrl="`echo $patchLine | cut -d ':' -f 7`"
  saCsum="`echo $patchLine | cut -d ':' -f 9`"
  local FILENAME="`basename $saUrl`"

  # Start downloading the patch
  touch ${TRIGGERFILE}
  echo "DOWNLOADING: ${saIdent}"
  echo "DOWNLOADING: ${saIdent}" >${TRIGGERFILE}

  # Get the file
  get_file "${saUrl}" "${DOWNLOADDIR}/${FILENAME}"
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE}
     echo "FAILED: ${saIdent}" >${TRIGGERFILE}
     exit_err "Failed to download: ${saIdent}"
  fi

  # Check the sha256 checksum
  if [ "$saCsum" != "`sha256 -q ${DOWNLOADDIR}/${FILENAME} 2>/dev/null`" ]
  then
     # Download MD5 doesn't match! Delete the file
     rm ${PATCHTMPFILE}
     rm ${DOWNLOADDIR}/${FILENAME}
     echo "FAILED: ${saIdent}" >${TRIGGERFILE}
     exit_err "Failed to download: ${saIdent}"
  else 
     echo "DOWNLOADFINISHED: ${saIdent}"
     echo "DOWNLOADFINISHED: ${saIdent}" >${TRIGGERFILE}
  fi

  echo "INSTALLING: ${saIdent}" >${TRIGGERFILE}
  sleep 1

  # Lets auto-create a new boot-environment before updating
  create_auto_beadm

  PATCHTMPDIR="`mktemp -d ${DOWNLOADDIR}/patchInstallXXXXX`"
  rc_halt "tar xvJf ${DOWNLOADDIR}/${FILENAME} -C ${PATCHTMPDIR}" 2>/dev/null
  PATCHDIR="$PATCHTMPDIR" ; export PATCHDIR
  cd ${PATCHTMPDIR}
  sh update.sh
  if [ $? -eq 0 ]; then
     touch "${INSDIR}/${SYSVER}/${saIdent}"
     echo "INSTALLFINISHED: ${saIdent}"
     echo "INSTALLFINISHED: ${saIdent}" >${TRIGGERFILE}
  else
     rm ${PATCHTMPFILE}
     rm -rf ${PATCHTMPDIR}
     rm ${DOWNLOADDIR}/${FILENAME}
     echo "INSTALLFAILED: ${saIdent}" >${TRIGGERFILE}
     exit_err "INSTALLFAILED: ${saIdent}"
  fi

  rc_halt "rm -rf ${PATCHTMPDIR}"
  rc_halt "rm ${DOWNLOADDIR}/${FILENAME}"
}

do_install() {
	if [ -z "$1" ] ; then exit_err "No updates specified to install!"; fi

	if [ -e "/usr/local/bin/pc-systemflag" ]; then
	  pc-systemflag SYSUPDATE UPDATING #set the flag that system is updating
	fi
	# Begin to update the selected items
	for up in `echo $1 | sed 's|,| |g'`
	do
	  # If this is a major update, start it up!
	  echo $up | grep -q "^fbsd-"
	  if [ $? -eq 0 ] ; then 
            update_world_and_pkgs "`echo $up | sed 's|fbsd-||g'`"
	    exit 0
          else
	    # Doing regular trueos patch
	    start_trueos_patch "${up}"
            continue
          fi
	done 
	if [ -e "/usr/local/bin/pc-systemflag" ]; then
	  pc-systemflag SYSUPDATE SUCCESS #set the flag that system updates finished
	fi
        # All Finished!
        rm ${PATCHTMPFILE}
        exit 0
}

is_net_up() {
	ping -c 1 www.trueos.org >/dev/null 2>/dev/null
	ret=$?
	if [ $ret -ne 0 ]; then
	  if [ -e "/usr/local/bin/pc-systemflag" ]; then
	    pc-systemflag NETRESTART ERROR #set the system flag that no internet available
	  fi
	fi
	return $ret
}

sync_pkgconf() {
  # Update systems pkgng configuration
  setup_pkgng_conf
}

check_pkgconf() {

  # Update systems pkgng configuration
  setup_pkgng_conf
  exit $?
}

checkup_pkgs() {

  # If using IPFS, we can check upstream for a newer package HASH
  if [ "$CDN_TYPE" = "IPFS" ] ; then
    get_latest_ipfs_hash
    if [ "$IPFS_HASH" != `cat /var/db/trueos-pkg-ipfs 2>/dev/null` ] ; then
      echo "The following updates are available:"
      echo "------------------------------------"
      echo "NAME: System package updates"
      echo "TYPE: PKGUPDATE"
      echo " "
      echo "To install: \"pc-updatemanager pkgupdate\""
      if [ -e "/usr/local/bin/pc-systemflag" ]; then
        pc-systemflag PKGUPDATE UPDATE #set the system flag that updates available
      fi
      return $PKGUPDATERTN
   else
      echo "All packages are up to date!"
      if [ -e "/usr/local/bin/pc-systemflag" ]; then
        pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
      fi
    fi
    return 0
  fi

  # Update the repo DB
  if [ "`id -u`" = "0" ] ; then
    echo "Updating the pkg database..."
    ${PKG_CMD} update >/tmp/.updateOut.$$ 2>&1
    if [ $? -ne 0 ] ; then
      grep -q "Newer FreeBSD version" /tmp/.updateOut.$$
      if [ $? -eq 0 ] ; then
        rm /tmp/.updateOut.$$
        updates_are_available
	return $?
      fi
    fi
    rm /tmp/.updateOut.$$
  fi

  ${PKG_CMD} ${PKG_FLAG} upgrade -n >/tmp/.pkgData.$$

  # Check for updates now
  grep -q "Your packages are up to date" /tmp/.pkgData.$$
  if [ $? -eq 0 ] ; then
     echo "All packages are up to date!"
     if [ -e "/usr/local/bin/pc-systemflag" ]; then
       pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
     fi
     rm /tmp/.pkgData.$$
     return 0
  fi

  # Display the pkg update data
  cat /tmp/.pkgData.$$
  rm /tmp/.pkgData.$$

  # We have updates
  updates_are_available
  return $?
}

updates_are_available()
{
  echo "The following updates are available:"
  echo "------------------------------------"
  echo "NAME: System package updates"
  echo "TYPE: PKGUPDATE"
  echo " "
  echo "To install: \"pc-updatemanager pkgupdate\""
  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE UPDATE #set the system flag that updates available
  fi
  return $PKGUPDATERTN
}

set_update_vars()
{
  unset EVENT_PIPE

  # Set some locations
  STAGEBE="updaterstage"
  STAGEMNT="/.updateStage"
  OLDPKGLIST="${STATEDIR}/.pkgUpdateList"
  NEWPKGLIST="${STATEDIR}/.newPkgUpdateList"
  PKGUPGRADELOG="${STATEDIR}/.pkgUpdateLog"
  PKGDLCACHE="/usr/local/pkg-cache"
  touch ${PKGUPGRADELOG}
  if [ -e "${STATEDIR}/.sysbaseorigin" ] ; then
    SYSBASEORIGIN=$(cat ${STATEDIR}/.sysbaseorigin)
  fi
  if [ -e "${STATEDIR}/.sysbasefilename" ] ; then
    SYSBASEFILENAME=$(cat ${STATEDIR}/.sysbasefilename)
  fi
  if [ -e "${STATEDIR}/.newfreebsdver" ] ; then
    NEWFREEBSDVERSION=$(cat ${STATEDIR}/.newfreebsdver)
  fi
  if [ -e "${STATEDIR}/.fullupdate" ] ; then
    FULLUPDATE=$(cat ${STATEDIR}/.fullupdate)
  fi
  if [ -e "${STATEDIR}/.doPkgUpdates" ] ; then
    doPkgUpdates=$(cat ${STATEDIR}/.doPkgUpdates)
  fi
  if [ -e "${STATEDIR}/.realpkgdlcache" ] ; then
    REALPKGDLCACHE=$(cat ${STATEDIR}/.realpkgdlcache)
  else
    REALPKGDLCACHE=${PKGDLCACHE}
  fi
}

# Check that beadm exists before doing an update
check_valid_uptarget()
{
  /usr/bin/which -s beadm
  if [ $? -ne 0 ] ; then
     exit_err "No beadm installed! Is this a jail or non PC-BSD / TrueOS box?"
  fi
}

update_pkgs_only()
{
  check_valid_uptarget

  FULLUPDATE="NO"
  if [ "$1" = "-f" ] ; then
    FULLUPDATE="YES"
  fi

  # SaveState
  echo "$FULLUPDATE" > ${STATEDIR}/.fullupdate

  # Make sure there are really packages to update
  if [ "$FULLUPDATE" != "YES" ] ; then
    checkup_pkgs >/dev/null 2>/dev/null
    if [ $? -eq 0 ] ; then
       echo "Your packages are already up to date!"
       exit 0
    fi
  fi

  # Make sure we have base system packages installed
  pkg-static info | grep -q "^FreeBSD-"
  if [ $? -ne 0 ] ; then
    echo "Boot-strapping package base..."
    pkg-static install -yfg 'FreeBSD-*'
  fi

  touch_updateinprogress
  doPkgUpdates="YES"

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE UPDATING #set the system flag that packages are updating
  fi

  set_update_vars

  run_update_pre "PKG"
  mk_pkg_conf "stage1"
  build_pkg_list
  dl_pkgs

  prep_update_shutdown "update_pkgs_only"
}

update_pkgs_only_stage2() {

  mk_pkg_conf "stage2"
  doPkgUpdates="YES"

  mk_stage_be
  mount_stage_be
  if [ "$FULLUPDATE" = "YES" ] ; then
    # We are doing a forced / full update, lets nuke and re-install all
    prep_pkgs_chroot "pkg"
    prep_rc_script_install
  else
    # Lets attempt a traditional PKG upgrade, fallback to full if that fails
    do_lite_pkgupdate_chroot
    if [ $? -ne 0 ] ; then
      echo_log "Failed incremental pkg upgrade! Doing full package upgrade now."
      prep_pkgs_chroot "pkg"
      prep_rc_script_install
    fi
  fi
  umount_stage_be
  mk_stage_be_default

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
  fi

  #run_update_post "PKG"
}

update_world_and_pkgs()
{
  check_valid_uptarget

  # Set the new version of FreeBSD we are installing
  NEWFREEBSDVERSION="$1"
  # Save State
  echo "$NEWFREEBSDVERSION" > ${STATEDIR}/.newfreebsdver

  doPkgUpdates="YES"

  touch_updateinprogress

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE UPDATING #set the system flag that packages are updating
  fi

  set_update_vars

  run_update_pre "SYSTEM"
  mk_pkg_conf "stage1"
  build_pkg_list
  dl_pkgs

  prep_update_shutdown "update_world_and_pkgs"
}

update_world_and_pkgs_stage2() {

  mk_pkg_conf "stage2"
  doPkgUpdates="YES"

  mk_stage_be
  mount_stage_be
  prep_pkgs_chroot "world"
  prep_rc_script_install
  umount_stage_be
  mk_stage_be_default

  if [ -e "/usr/local/bin/pc-systemflag" ]; then
    pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
  fi

  run_update_post "SYSTEM"
}

mk_pkg_conf()
{
  PKG_FLAG=""
  PKG_CFLAG=""

  if [ ! -d "$REALPKGDLCACHE" ] ; then
    mkdir -p $REALPKGDLCACHE
  fi

  # Get rid of FreeBSD.conf repo
  if [ -e "/etc/pkg/FreeBSD.conf" ] ; then
     rm /etc/pkg/FreeBSD.conf
  fi

  # Set the cache directory
  PKG_CFLAG="-C /var/db/pc-updatemanager/.pkgUpdate.conf"
  if [ ! -d "/var/db/pc-updatemanager" ] ; then
    mkdir -p "/var/db/pc-updatemanager"
  fi
  echo "PKG_CACHEDIR: $REALPKGDLCACHE" > /var/db/pc-updatemanager/.pkgUpdate.conf
  echo "PKG_DBDIR: /var/db/pc-updatemanager/pkgdb" >> /var/db/pc-updatemanager/.pkgUpdate.conf
  echo "IGNORE_OSVERSION: YES" >> /var/db/pc-updatemanager/.pkgUpdate.conf

  # If we are starting an upgrade, we need to "prime" the new PKG_DBDIR
  # This is done so if the user decides to use 'pkg' after an update is staged, we don't
  # invalidate all our package repo data
  if [ "$1" = "stage1" ] ; then
    rm -rf /var/db/pc-updatemanager/pkgdb
    cp -r /var/db/pkg /var/db/pc-updatemanager/pkgdb
    if [ $? -ne 0 ] ; then
      echo_log "Failed copying PKG DB..."
      exit 1
    fi
  fi

  # If doing a major update also, add the new repos config
  if [ -n "$NEWFREEBSDVERSION" ] ; then
     setup_pkgng_newrepo_conf
  fi
}

setup_pkgng_newrepo_conf() {

  # Lets create a new repo file to match the version of BSD we are upgrading to

  # Set the new ABI
  ABIVER="`echo $NEWFREEBSDVERSION | cut -d '-' -f 1 | cut -d '.' -f 1`"
  PKG_FLAG="$PKG_FLAG -o ABI=freebsd:$ABIVER:`uname -m`"
  #PKG_FLAG="$PKG_FLAG -o ABI=freebsd:$ABIVER:x86:64"
  #echo "Setting ABI with: ${PKG_FLAG}"

  # See if we need to adjust trueos.conf repo file
  if [ ! -e "/usr/local/etc/pkg/repos/trueos.conf.dist" ];then
     echo_log "ERROR: Missing /usr/local/etc/pkg/repos/trueos.conf.dist"
     exit 1
  fi

  ARCH=`uname -m`
  PKGVER="master"

  if [ "$CDN_TYPE" = "IPFS" ] ; then
	get_latest_ipfs_hash
	echo "$IPFS_HASH" > /var/db/trueos-pkg-ipfs-next
	ipfshash="${IPFS_HASH}"
	PACKAGE_SET="CUSTOM"
	CUSTOM_URL="http://127.0.0.1:8080/ipfs/${ipfshash}/${ARCH}"

	# Make sure the IPFS daemon is running
	service ipfs-go status >/dev/null 2>/dev/null
	if [ $? -ne 0 ] ; then
		(service ipfs-go start >/dev/null 2>/dev/null) &
	fi
	# Make sure the daemon is set to run at startup
	rc-update show default | grep -q ipfs-go
	if [ $? -ne 0 ] ; then
		rc-update add ipfs-go default #>/dev/null 2>dev/null
	fi
  fi

  # If using the UNSTABLE package set, set the right path
  case $PACKAGE_SET in
    UNSTABLE|EDGE) PKGVER="unstable" ;;
          *) ;;
  esac

  # Create the repo config dirs
  rm -rf /usr/local/tmp/.updateRepo >/dev/null 2>/dev/null
  mkdir -p /usr/local/tmp/.updateRepo

  # Copy over all the repos and remove the trueos ones we will replace
  cp /etc/pkg/*.conf /usr/local/tmp/.updateRepo/ 2>/dev/null
  cp /usr/local/etc/pkg/repos/*.conf /usr/local/tmp/.updateRepo/ 2>/dev/null
  rm /usr/local/tmp/.updateRepo/trueos-base.conf 2>/dev/null
  rm /usr/local/tmp/.updateRepo/trueos.conf 2>/dev/null

  # Now create standard trueos.conf file
  if [ "$PACKAGE_SET" = "CUSTOM" -a -n "$CUSTOM_URL" ] ; then
     # Change %VERSION% / %ARCH% keys
     CUSTOM_URL=`echo $CUSTOM_URL | sed "s|%VERSION%|$PKGVER|g" | sed "s|%ARCH%|$ARCH|g" | sed 's|/$||g'`
     cat << EOF >/usr/local/tmp/.updateRepo/pkgUpdateRepo.conf
trueos-major: {
               url: "$CUSTOM_URL",
               signature_type: "fingerprints",
               fingerprints: "/usr/local/etc/pkg/fingerprints/trueos",
               enabled: true
              }
trueos-base: {
               url: "${CUSTOM_URL}-base",
               signature_type: "fingerprints",
               fingerprints: "/usr/local/etc/pkg/fingerprints/trueos",
               enabled: true
              }
EOF
  else
    # Using PC-BSD CDN
    cat /usr/local/etc/pkg/repos/trueos.conf.dist \
      | sed "s|trueos: |trueos-major: |g" \
      | sed "s|%VERSION%|$PKGVER|g" \
      | sed "s|%ARCH%|$ARCH|g" > /usr/local/tmp/.updateRepo/pkgUpdateRepo.conf
    cat /usr/local/etc/pkg/repos/trueos.conf.dist \
      | sed "s|trueos: |trueos-base: |g" \
      | sed "s|%VERSION%|$PKGVER|g" \
      | sed "s|%ARCH%|${ARCH}-base|g" >> /usr/local/tmp/.updateRepo/pkgUpdateRepo.conf
  fi

  # Set the new PKG_FLAG to use this repo config
  PKG_FLAG="-R /usr/local/tmp/.updateRepo ${PKG_FLAG}"
}

build_pkg_list()
{
  # Check if any packages are locked and bail if so
  pkg-static lock --has-locked-packages >/dev/null 2>/dev/null
  if [ $? -eq 0 ] ; then
    lockedList=$(pkg-static lock --show-locked -q | grep -v "trueos-")
    if [ -n "$lockedList" ] ; then
      if [ -e "/usr/local/bin/pc-systemflag" ] ; then
        pc-systemflag PKGUPDATE ERROR
      fi
      exit_err "You have LOCKED packages in your repo! These must be unlocked, or you can run pkg upgrade manually."
    fi
  fi

  # Figure out which base to install
  pkg-static info -e trueos-desktop
  if [ $? -eq 0 -o -e "/etc/defaults/trueos-desktop" ] ; then
     SYSBASE="misc/trueos-desktop"
  else
     SYSBASE="misc/trueos-server"
  fi
  SYSBASEORIGIN="$SYSBASE"

  # SaveState
  echo "$SYSBASEORIGIN" > ${STATEDIR}/.sysbaseorigin

  # Build top-level list of pkgs installed
  ${PKG_CMD} query -e '%a = 0' '%o %n-%v' | grep -v "^base" | sort | grep -v 'ports-mgmt/pkg ' | grep -v 'misc/trueos-desktop ' | grep -v 'misc/trueos-server ' > $OLDPKGLIST

  # If GRUB is used for boot, require it to be installed
  if [ -e "/boot/grub/grub.cfg" ]; then
     echo "sysutils/grub2-trueos grub2-trueos" >> $OLDPKGLIST
     echo "sysutils/grub2-efi grub2-efi" >> $OLDPKGLIST
  fi

  echo "Original top-level packages:" > $PKGUPGRADELOG
  echo "-----------------------------------------------" >> $PKGUPGRADELOG
  cat $OLDPKGLIST >> $PKGUPGRADELOG
  echo "-----------------------------------------------" >> $PKGUPGRADELOG
}

###
# Helper to run pkg fetch commands in a loop since timeouts may not be fatal if we try again
###
pkg_fetch_verify() {

  local fetchPkg="$1"
  local fetchPkgFile="$2"
  local fetchRetries="$3"

  if [ -z "$fetchRetries" ] ; then
    fetchRetries="0"
    echo_log "Verifying / fetching packages for $fetchPkg - $fetchPkgFile"
    echo "Verifying / fetching packages for $fetchPkg - $fetchPkgFile" >> ${PKGUPGRADELOG}
  fi

  if [ $fetchRetries -gt 3 ] ; then
     # Exeeded the number of retry attempts
     # Time to fail out
     if [ -e "/usr/local/bin/pc-systemflag" ] ; then
       pc-systemflag PKGUPDATE ERROR
     fi
     echo_log "Failed fetching: $fetchPkg - $fetchPkgFile" >> ${PKGUPGRADELOG}
     exit_err "Failed fetching: $fetchPkg - $fetchPkgFile"
  fi

  # Increment number of retry attempts
  fetchRetries=$(expr $fetchRetries + 1)

  # Attempt to fetch the package
  run_cmd_wtee "${PKG_CMD} ${PKG_CFLAG} ${PKG_FLAG} fetch -U -d -y $fetchPkg" "${PKGUPGRADELOG}"
  _err=$?
  tail -n 1 ${PKGUPGRADELOG} | grep -q -e "failed checksum" -e "timed out"
  if [ $_err -ne 0 -o $? -eq 0 ]; then
    pkg_fetch_verify "$fetchPkg" "$fetchPkgFile" "$fetchRetries"
  fi

  REALPKGDLCACHE="${PKGDLCACHE}"
  # PKGNG lies, we need to verify if the package was really downloaded
  if [ ! -e "${PKGDLCACHE}/${fetchPkgFile}" ] ; then
     # Also check All/ since pkg docs are rather unclear about if that will be used or not
     if [ -e "${PKGDLCACHE}/All/${fetchPkgFile}" ] ; then
        REALPKGDLCACHE="${PKGDLCACHE}/All"
     else
        pkg_fetch_verify "$fetchPkg" "$fetchPkgFile" "$fetchRetries"
     fi
  fi
}

dl_pkgs()
{
  unset OBSOLETE_PACKAGES

  # Setup the removedpkglist
  if [ ! -e "${STATEDIR}/.removed-pkg-list" ] ; then
    rm ${STATEDIR}/.removed-pkg-list
  fi
  touch ${STATEDIR}/.removed-pkg-list

  # Make sure PKG itself is upgraded
  #echo_log "Checking for updates to ports-mgmt/pkg.."
  #${PKG_CMD} upgrade -y ports-mgmt/pkg

  # Get the URL for the base packages
  echo $PKG_FLAG | grep -q "/usr/local/tmp/.updateRepo"
  if [ $? -eq 0 ] ; then
    BPURL=$(cat /usr/local/tmp/.updateRepo/pkgUpdateRepo.conf | grep 'url:' | tail -n 1 | awk '{print $2}' | cut -d '"' -f 2)
    PURL=$(cat /usr/local/tmp/.updateRepo/pkgUpdateRepo.conf | grep 'url:' | head -n 1 | awk '{print $2}' | cut -d '"' -f 2)
  else
    BPURL=$(cat /usr/local/etc/pkg/repos/trueos-base.conf | grep 'url:' | awk '{print $2}' | cut -d '"' -f 2)
    PURL=$(cat /usr/local/etc/pkg/repos/trueos.conf | grep 'url:' | awk '{print $2}' | cut -d '"' -f 2)
  fi

  # Fetch the updated version of PKG
  PTMPDIR="/var/run/pc-updatemanager/pkgbs"
  rm -rf ${PTMPDIR}
  mkdir -p ${PTMPDIR}
  echo_log "Boot-strapping latest PKGNG"

  # Work-around issue with fetch not being able to pull down a symlink'd pkg file
  if [ "$CDN_TYPE" = "IPFS" ] ; then
    _IPHASH="/$(echo $PURL/Latest/pkg.txz| cut -d '/' -f 4-)"
    ipfs-go get -o ${PTMPDIR}/pkg.txz $_IPHASH
    _PKGFILE=$(readlink ${PTMPDIR}/pkg.txz)
    if [ -z "${_PKGFILE}" ] ; then
      mv "${PTMPDIR}/pkg.txz" "${PTMPDIR}/.pkg.txz.$$"
    else
      # Fetch the real filename
      get_file "${PURL}/Latest/${_PKGFILE}" "${PTMPDIR}/.pkg.txz.$$" "3"
      if [ ! -e "${PTMPDIR}/.pkg.txz.$$" ] ; then
        exit_err "Failed bootstrapping latest PKG"
      fi
    fi
  else
    _PKGFILE="pkg.txz"
    # Fetch the real filename
    get_file "${PURL}/Latest/${_PKGFILE}" "${PTMPDIR}/.pkg.txz.$$" "3"
    if [ ! -e "${PTMPDIR}/.pkg.txz.$$" ] ; then
      exit_err "Failed bootstrapping latest PKG"
    fi
  fi

  tar xvf ${PTMPDIR}/.pkg.txz.$$ -C ${PTMPDIR} /usr/local/sbin/pkg-static 2>/dev/null >/dev/null
  if [ $? -ne 0 ] ; then
    exit_err "Failed extracting latest PKG"
  fi
  PKG_CMD="${PTMPDIR}/usr/local/sbin/pkg-static"

  # Update the DB first
  echo_log "Updating the package repo database..."
  ${PKG_CMD} ${PKG_FLAG} update -f >/dev/null 2>/dev/null
  sync
  sleep 2

  # Clean pkgs
  echo_log "Cleaning old pkg upgrade cache..."
  ${PKG_CMD} ${PKG_CFLAG} ${PKG_FLAG} clean -y >/dev/null 2>/dev/null
  sync
  sleep 2

  if [ -e "$NEWPKGLIST" ] ; then rm $NEWPKGLIST; fi
  touch ${NEWPKGLIST}

  # Fetch the fbsd-distrib.txz file
  echo "fetch -o ${REALPKGDLCACHE}/fbsd-distrib.txz ${BPURL}/fbsd-distrib.txz"
  fetch -o ${REALPKGDLCACHE}/fbsd-distrib.txz "${BPURL}/fbsd-distrib.txz"
  if [ $? -ne 0 ] ; then
     echo_log "Failed downloading fbsd-distrib.txz" >> ${PKGUPGRADELOG}
     exit_err "Failed downloading fbsd-distrib.txz"
  fi
  fetch -o ${REALPKGDLCACHE}/fbsd-distrib.txz.sha1 "${BPURL}/fbsd-distrib.txz.sha1"
  if [ $? -ne 0 ] ; then
     echo_log "Failed downloading fbsd-distrib.txz.sha1" >> ${PKGUPGRADELOG}
     exit_err "Failed downloading fbsd-distrib.txz.shg1"
  fi

  # Verify Signature of the fbsd-distrib file
  openssl dgst -sha1 -verify /usr/local/share/trueos/pc-updatemanager/fbsd-dist.pub  -signature ${REALPKGDLCACHE}/fbsd-distrib.txz.sha1 ${REALPKGDLCACHE}/fbsd-distrib.txz
  if [ $? -ne 0 ] ; then
     echo_log "Failed verification of fbsd-distrib.txz" >> ${PKGUPGRADELOG}
     exit_err "Failed verification of fbsd-distrib.txz"
  fi

  ###
  # Fetch the ports-mgmt/pkg
  ###
  PKGFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery -U '%n-%v' ports-mgmt/pkg 2>/dev/null | head -n 1`.txz"

  # Update the database once
  run_cmd_wtee "${PKG_CMD} ${PKG_CFLAG} ${PKG_FLAG} update" "${PKGUPGRADELOG}"

  # Download the ports-mgmt/pkg commands
  pkg_fetch_verify "ports-mgmt/pkg" "$PKGFILENAME"

  # Save State of REALPKGDLCACHE
  echo "${REALPKGDLCACHE}" > ${STATEDIR}/.realpkgdlcache

  ###
  # Fetch the SYSBASE
  ###
  SYSBASEFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery -U '%n-%v' $SYSBASE 2>/dev/null | head -n 1`.txz"

  # Download
  pkg_fetch_verify "$SYSBASE" "$SYSBASEFILENAME"

  echo "$SYSBASEORIGIN" > ${STATEDIR}/.sysbaseorigin
  echo "$SYSBASEFILENAME" > ${STATEDIR}/.sysbasefilename
  export SYSBASEFILENAME SYSBASEORIGIN

  ###
  # Now start fetching all the update packages
  ###
  while read pkgLine
  do
    pkgOrigin="`echo $pkgLine | cut -d ' ' -f 1`"
    pkgName="`echo $pkgLine | cut -d ' ' -f 2`"

    # Check if this pkg exists in the new repo
    unset FETCHFILENAME
    echo_log "Determining package name for: ${pkgOrigin}"
    echo "Determining package name for ${pkgOrigin}" >> ${PKGUPGRADELOG}
    FETCHFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery -U '%n-%v' $pkgOrigin 2>/dev/null | head -n 1`"
    if [ -z "$FETCHFILENAME" ] ; then
       OBSOLETE_PACKAGES="${pkgOrigin} ${OBSOLETE_PACKAGES}"
       echo_log "*****"
       echo_log "No such package in new repo: $pkgOrigin"
       echo "*****" >> $PKGUPGRADELOG
       echo "No such package in new repo: $pkgOrigin" >> $PKGUPGRADELOG
       echo "$pkgOrigin" >> ${STATEDIR}/.removed-pkg-list
       echo "*****" >> $LOGOUT
       echo "*****" >> $PKGUPGRADELOG
       continue
    fi
    FETCHFILENAME="${FETCHFILENAME}.txz"

    # Download
    pkg_fetch_verify "$pkgOrigin" "$FETCHFILENAME"

    echo "$pkgOrigin $FETCHFILENAME" >> $NEWPKGLIST
  done < $OLDPKGLIST

  # Doing a world upgrade, lets fetch FreeBSD packages
  echo_log "Verifying / fetching packages for FreeBSD Base"
  echo "Verifying / fetching packages for FreeBSD Base" >> ${PKGUPGRADELOG}
  attempts=0
  while :
  do
    attempts=$(expr $attempts + 1)
    run_cmd_wtee "${PKG_CMD} ${PKG_CFLAG} ${PKG_FLAG} fetch -U -d -y -g FreeBSD-*" "${PKGUPGRADELOG}"
    _err=$?
    tail -n 1 ${PKGUPGRADELOG} | grep -q -e "failed checksum" -e "timed out" -e "not found" -e "No packages"
    if [ $_err -ne 0 -o $? -eq 0 ]; then
      if [ $attempts -gt 3 ] ; then
        echo_log "*****" ${PKGUPGRADELOG}
        echo_log "Failed fetching: FreeBSD Base" >> ${PKGUPGRADELOG}
        exit_err "Failed fetching: FreeBSD Base"
      fi
    else
      break
    fi
  done

  echo_log "-----------------------------------------------"
  echo "-----------------------------------------------" >> ${PKGUPGRADELOG}
}

prep_rc_script_install()
{
  # Clear the trigger file
  rm ${STAGEMNT}/var/.pc-attempt1 2>/dev/null

  # Now prep the RC script to do the rest of the upgrade after reboot
  rc_halt_cleanup "mv ${STAGEMNT}/etc/rc ${STAGEMNT}/etc/rc-orig"
  rc_halt_cleanup "mkdir -p ${STAGEMNT}/compat/linux/proc"
  rc_halt_cleanup "mkdir -p ${STAGEMNT}/compat/linux/sys"
  rc_halt_cleanup "mkdir -p ${STAGEMNT}/compat/linux/usr"
  rc_halt_cleanup "mkdir -p ${STAGEMNT}/compat/linux/dev"
  rc_halt_cleanup "mkdir -p ${STAGEMNT}/compat/linux/run"
  rc_halt_cleanup "cp /usr/local/sbin/beadm ${STAGEMNT}/etc/beadm"
  rc_halt_cleanup "chmod 755 ${STAGEMNT}/etc/beadm"
  rc_halt_cleanup "cp ${PROGDIR}/rc-update ${STAGEMNT}/etc/rc"
  rc_halt_cleanup "cp ${PROGDIR}/rc-update ${STAGEMNT}/etc/rc-update"
  rc_halt_cleanup "cp ${PROGDIR}/rc-doupdate ${STAGEMNT}/etc/rc-doupdate"
}

check_low_space()
{
  if [ -z "${REALPKGDLCACHE}" ] ; then return; fi
  if [ ! -d "${REALPKGDLCACHE}" ] ; then return; fi

  local poolFree=$(get_root_pool_free_space)
  if [ -z "$poolFree" ] ; then return ; fi

  cd ${REALPKGDLCACHE}
  local pkgCacheSpace=`du -kc *.txz | tail -1 | awk '{print $1}'`
  if [ ! $(is_num "$pkgCacheSpace") ] ; then return ; fi

  # We try to over-estimate space required for decompression, since we don't want ZFS to get
  # too full, it gets cranky at over 75%
  pkgCacheSpace=`expr $pkgCacheSpace \* 3`

  if [ $poolFree -lt $pkgCacheSpace ] ; then
     do_prune_be "force"
     poolFree=$(get_root_pool_free_space)
     if [ $poolFree -lt $pkgCacheSpace ] ; then
        SPACE=`expr $pkgCacheSpace / 1024`
        exit_err "Low disk-space - update halted! Please free at least ${SPACE}MB before running again."
     fi
  fi
}

mk_stage_be()
{
  echo_log "Creating stage BE..."
  umount -f $STAGEMNT/dev 2>/dev/null >/dev/null
  umount -f $STAGEMNT 2>/dev/null >/dev/null

  # Auto-prune any old / stale BEs
  do_prune_be

  # Do the low-space check
  check_low_space

  # Check for an existing BE for upgrades
  beadm list -H | awk '{print $1}' | grep -q "$STAGEBE"
  if [ $? -eq 0 ] ; then
     beadm destroy -F $STAGEBE
  fi

  # Create the new stage boot environment
  rc_halt "beadm create $STAGEBE" >>${LOGOUT} 2>>${LOGOUT}
}

mount_stage_be()
{
  # Get the stage mount-point ready
  echo_log "Mounting the stage BE..."
  if [ ! -d "$STAGEMNT" ] ; then mkdir -p $STAGEMNT; fi
  umount -f $STAGEMNT/dev 2>/dev/null >/dev/null
  umount -f $STAGEMNT 2>/dev/null >/dev/null

  # Mount the BE
  rc_halt "beadm mount $STAGEBE $STAGEMNT"
  if [ "$doPkgUpdates" = "YES" ] ; then
    rc_halt_cleanup "cp $NEWPKGLIST ${STAGEMNT}/install-pkg-list"
  fi
  rc_halt_cleanup "mount -t devfs devfs ${STAGEMNT}/dev"

  # Save list of previous packages
  ${PKG_CMD} info >${STAGEMNT}/previous-pkg-list

  # Copy over Xorg.0.log since we probe that file on trueos-desktop
  if [ -e "/var/log/Xorg.0.log" ] ; then
    rc_halt_cleanup "cp /var/log/Xorg.0.log ${STAGEMNT}/var/log/Xorg.0.log"
  fi
}

do_lite_pkgupdate_chroot()
{
  # Need to export this before cleaning pkgs, some scripts may try to be interactive
  PACKAGE_BUILDING="YES"
  export PACKAGE_BUILDING

  # This sucks, but we have to do it. If FreeBSD version gets bumped AT ALL, we need to do full-update
  CRUNTIME="`${PKG_CMD} ${PKG_FLAG} query '%n-%v' FreeBSD-Runtime-development 2>/dev/null | head -n 1`"
  NRUNTIME="`${PKG_CMD} ${PKG_FLAG} rquery -U '%n-%v' FreeBSD-Runtime-development 2>/dev/null | head -n 1`"
  if [ "$CRUNTIME" != "$NRUNTIME" ] ; then
    echo_log "FreeBSD base system update detected!"
    echo_log "Falling back to full upgrade"
    return 1
  fi

  # Save the current ABI version of the system
  CURRENTABI=`grep "^#define __FreeBSD_version" /usr/include/sys/param.h | awk '{print $3}'`

  # Locate the right FreeBSD-runtime-development
  RUNTIMEFILE="`${PKG_CMD} ${PKG_FLAG} rquery -U '%n-%v' FreeBSD-Runtime-development 2>/dev/null | head -n 1`.txz"
  if [ ! -e "${REALPKGDLCACHE}/${RUNTIMEFILE}" ] ; then
    echo_log "Can't locate FreeBSD-Runtime-development package: $RUNTIMEFILE"
    return 1;
  fi

  # Extract the /usr/include/sys/param.h file
  rm -rf /tmp/pc-param-check
  mkdir /tmp/pc-param-check
  tar xvpf ${REALPKGDLCACHE}/${RUNTIMEFILE} -C /tmp/pc-param-check -s "|/usr/include/sys||" /usr/include/sys/param.h >/dev/null 2>/dev/null
  if [ ! -e "/tmp/pc-param-check/param.h" ] ; then
    echo_log "Unable to locate param.h from ${REALPKGDLCACHE}/${RUNTIMEFILE}"
    return 1;
  fi

  # Check the ABI version of the new system, if changed we need to fallback to a full install
  NEWABI=`grep "^#define __FreeBSD_version" /tmp/pc-param-check/param.h | awk '{print $3}'`
  rm -rf /tmp/pc-param-check
  if [ "$CURRENTABI" != "$NEWABI" ] ; then
    echo_log "ABI Change detected, Old: $CURRENTABI New: $NEWABI"
    echo_log "Falling back to full upgrade"
    return 1
  fi

  # Set the cache directory
  PKG_CFLAG="-C /var/db/pc-updatemanager/.pkgUpdate.conf"
  echo "PKG_CACHEDIR: $REALPKGDLCACHE" > ${STAGEMNT}/var/db/pc-updatemanager/.pkgUpdate.conf
  echo "PKG_DBDIR: /var/db/pc-updatemanager/pkgdb" >> ${STAGEMNT}/var/db/pc-updatemanager/.pkgUpdate.conf

  echo_log "Starting pkg upgrade..."
  rc_halt_cleanup "chroot ${STAGEMNT} pkg-static unlock -ay" 2>&1 | tee -a ${LOGOUT}

  # Bad PKG, bad!
  chroot ${STAGEMNT} pkg-static ${PKG_CFLAG} ${PKG_FLAG} delete -y javavmwrapper-2.5_1 2>/dev/null >/dev/null
  chroot ${STAGEMNT} pkg-static ${PKG_CFLAG} ${PKG_FLAG} delete -y javavmwrapper-2.5_2 2>/dev/null >/dev/null

  echo_log "Running: pkg-static upgrade -U -y"
  rc_nohalt "chroot ${STAGEMNT} pkg-static ${PKG_CFLAG} ${PKG_FLAG} upgrade -U -y" 2>&1 | tee -a ${LOGOUT} | tee -a ${LOGOUT}.tmp
  _err=$STATUS
  if [ $_err -ne 0 ] ; then
    echo_log "Failed running pkg-static upgrade -U -y"
    rm ${LOGOUT}.tmp
    return 1
  fi

  # We've seen cases of pkg returning 0, but really it failed... Lets try to catch this
  cat ${LOGOUT}.tmp | grep -q "Cannot solve problem using SAT"
  if [ $? -eq 0 ] ; then
    rm ${LOGOUT}.tmp
    return 1
  fi

  # Verify the base package was installed
  chroot ${STAGEMNT} pkg-static ${PKG_CFLAG} ${PKG_FLAG} info -q $SYSBASEORIGIN
  if [ $? -ne 0 ] ; then
    echo_log "Lite upgrade removed $SYSBASEORIGIN, falling back to full update"
    return 1
  fi

  # Set all pkgs as not auto-installed, so pkg autoremove doesn't touch them
  chroot ${STAGEMNT} pkg-static ${PKG_CFLAG} ${PKG_FLAG} set -y -A 00 -g FreeBSD-\*

  # Lock the TrueOS base package
  chroot ${STAGEMNT} pkg-static ${PKG_CFLAG} ${PKG_FLAG} lock -y ${SYSBASEORIGIN}

  # Looks like the upgrade was good! Lets move back the PKG repo
  echo_log "Moving updated pkg repo..."
  rm -rf ${STAGEMNT}/var/db/pkg.preUpgrade 2>/dev/null
  mv ${STAGEMNT}/var/db/pkg ${STAGEMNT}/var/db/pkg.preUpgrade
  mv ${STAGEMNT}/var/db/pc-updatemanager/pkgdb ${STAGEMNT}/var/db/pkg

  # Workaround to issue in FreeBSD pkg base
  chown root:operator ${STAGEMNT}/sbin/shutdown
  chmod 4554 ${STAGEMNT}/sbin/shutdown

  # Boot gets cranky if these go away
  mkdir -p ${STAGEMNT}/compat/linux/proc 2>/dev/null
  mkdir -p ${STAGEMNT}/compat/linux/sys 2>/dev/null
  mkdir -p ${STAGEMNT}/compat/linux/usr 2>/dev/null
  mkdir -p ${STAGEMNT}/compat/linux/dev 2>/dev/null
  mkdir -p ${STAGEMNT}/compat/linux/run 2>/dev/null

  if [ -e "${STAGEMNT}/etc/init.d" ] ; then

    # Update some of the etc files from 'make distribution'
    echo_log "Extracting distribution files..."
    tar xvpf ${REALPKGDLCACHE}/fbsd-distrib.txz -C ${STAGEMNT} ${ETC_DISTUPGRADE}
    if [ $? -ne 0 ] ; then
      echo_log "Warning: Failed extracting distribution upgrade files"
    fi

    echo_log "Updating OpenRC settings..."

    # Make sure the various openrc dirs exist
    mkdir -p ${STAGEMNT}/etc/runlevels 2>/dev/null
    mkdir -p ${STAGEMNT}/etc/runlevels/boot 2>/dev/null
    mkdir -p ${STAGEMNT}/etc/runlevels/default 2>/dev/null
    mkdir -p ${STAGEMNT}/etc/runlevels/nonetwork 2>/dev/null
    mkdir -p ${STAGEMNT}/etc/runlevels/shutdown 2>/dev/null
    mkdir -p ${STAGEMNT}/etc/runlevels/sysinit 2>/dev/null
    mkdir -p ${STAGEMNT}/libexec/rc/init.d 2>/dev/null

    # Enable OpenRC Services
    for serv in ${OPENRC_BOOT_SERV}
    do
       chroot ${STAGEMNT} rc-update add $serv boot
    done
    for serv in ${OPENRC_DEFAULT_SERV}
    do
       chroot ${STAGEMNT} rc-update add $serv default
    done
    for serv in ${OPENRC_SHUTDOWN_SERV}
    do
       chroot ${STAGEMNT} rc-update add $serv shutdown
    done
    for serv in ${OPENRC_NONET_SERV}
    do
       chroot ${STAGEMNT} rc-update add $serv nonetwork
    done
  fi

  # Determine if we need to do first-time rc -> openrc migration
  if [ ! -e "${STAGEMNT}/var/migrate-rc-openrc" ] ; then
    echo_log "Running OpenRC Migration..."
    chroot ${STAGEMNT} /usr/local/bin/migrate_rc_openrc
    touch "${STAGEMNT}/var/migrate_rc_openrc"
  fi

  rm ${LOGOUT}.tmp
  return 0
}

prep_pkgs_chroot()
{
  # Now start our chroot commands

  # Need to export this before cleaning pkgs, some scripts may try to be interactive
  PACKAGE_BUILDING="YES"
  export PACKAGE_BUILDING

  PKG_CMD="${PTMPDIR}/usr/local/sbin/pkg-static"
  if [ ! -e "$PKG_CMD" ] ; then
    echo_log "Missing boot-strapped PKG binary!"
    exit 1
  fi

  # Always install the latest base system packages
  echo_log "Boot-strapping package base..."
  ${PKG_CMD} -c ${STAGEMNT} ${PKG_CFLAG} ${PKG_FLAG} install -yfg 'FreeBSD-*' >>${LOGOUT} 2>>${LOGOUT}
  if [ $? -ne 0 ] ; then
    echo_log "FAILED INSTALLING world base packages"
    exit 1
  fi

  # Set all pkgs as not auto-installed, so pkg autoremove doesn't touch them
  echo_log "Marking FreeBSD packages as not auto-installed"
  ${PKG_CMD} -c ${STAGEMNT} ${PKG_CFLAG} ${PKG_FLAG} set -y -A 00 -g FreeBSD-\* >>${LOGOUT} 2>>${LOGOUT}

  # Check if something went horribly wrong
  if [ ! -e "${STAGEMNT}/bin/sh" ] ; then
     ABI_FLAG="-o ABI=freebsd:`uname -r | cut -c 1-2`:`uname -m`"
     ${PKG_CMD} -c ${STAGEMNT} ${PKG_CFLAG} ${PKG_FLAG} ${ABI_FLAG} install -yfg 'FreeBSD-*' >>${LOGOUT} 2>>${LOGOUT}
     if [ ! -e "${STAGEMNT}/bin/sh" ] ; then
       echo_log "Missing ${STAGEMNT}/bin/sh: Something went horribly wrong!"
       exit 1
     fi
  fi

  # Work around an issue with some kmod pkgs which can hang the box before upgrade happens
  ${PKG_CMD} -c ${STAGEMNT} ${PKG_CFLAG} ${PKG_FLAG} unlock -ay >>${LOGOUT} 2>>${LOGOUT}
  ${PKG_CMD} -c ${STAGEMNT} ${PKG_CFLAG} ${PKG_FLAG} delete -yg '*kmod*' >>${LOGOUT} 2>>${LOGOUT}
  ${PKG_CMD} -c ${STAGEMNT} ${PKG_CFLAG} ${PKG_FLAG} delete -yg '*nvidia-driver*' >>${LOGOUT} 2>>${LOGOUT}

  # Workaround to issue in FreeBSD pkg base
  chown root:operator ${STAGEMNT}/sbin/shutdown
  chmod 4554 ${STAGEMNT}/sbin/shutdown

  # Copy the doPkgUp.sh template
  rc_halt "cp ${PROGDIR}/doPkgUp.sh ${STAGEMNT}/.doPkgUp.sh"

  # Set the dynamic variables
  sed -i '' "s|%%PKG_FLAG%%|${PKG_FLAG}|g" ${STAGEMNT}/.doPkgUp.sh
  sed -i '' "s|%%REALPKGDLCACHE%%|${REALPKGDLCACHE}|g" ${STAGEMNT}/.doPkgUp.sh
  sed -i '' "s|%%PKGFILENAME%%|${PKGFILENAME}|g" ${STAGEMNT}/.doPkgUp.sh
  sed -i '' "s|%%SYSBASEFILENAME%%|${SYSBASEFILENAME}|g" ${STAGEMNT}/.doPkgUp.sh
  sed -i '' "s|%%SYSBASEORIGIN%%|${SYSBASEORIGIN}|g" ${STAGEMNT}/.doPkgUp.sh

}

install_pkgs_chroot()
{
  # Run it now
  echo_log "Installing packages to stage BE... (This may take a while)"
  rc_halt_cleanup "chroot ${STAGEMNT} sh /.doPkgUp.sh" 2>&1 | tee -a ${LOGOUT}
  rm ${STAGEMNT}/.doPkgUp.sh
}

umount_stage_be()
{
  echo_log "Unmounting stage BE..."
  if [ ! -d "${STAGEMNT}/usr/local/log/pc-updatemanager" ] ; then
     mkdir -p "${STAGEMNT}/usr/local/log/pc-updatemanager"
  fi

  # Save the old BE name
  oldBE=`beadm list | grep ' / ' | awk '{print $1}'`
  echo "${oldBE}" > ${STAGEMNT}/var/.lastGoodBE

  echo_log "Copy upgrade.log to new BE..."
  rc_halt_cleanup "cp ${PKGUPGRADELOG} ${STAGEMNT}/usr/local/log/pc-updatemanager/upgrade.log"
  rc_halt_cleanup "cp ${STATEDIR}/.removed-pkg-list ${STAGEMNT}/removed-pkg-list"

  # Figure out the name of the new BE
  echo_log "Determine new BE name..."
  nDate=`date "+%Y%m%d_%H%M%S"`
  if [ -n "$NEWFREEBSDVERSION" ] ; then
    newBEName="${NEWFREEBSDVERSION}-up-${nDate}"
  else
    beVer="`chroot ${STAGEMNT} /bin/freebsd-version`"
    if [ -z "$beVer" ] ; then
      beVer="`uname -r`"
    fi
    newBEName="${beVer}-up-${nDate}"
  fi

  echo_log "Cleanup mounts..."

  # Now cleanup / unmount
  rc_halt "umount -f ${STAGEMNT}/dev"

  # Remove old Xorg.0.log
  if [ -e "${STAGEMNT}/var/log/Xorg.0.log" ] ; then
    rm ${STAGEMNT}/var/log/Xorg.0.log
  fi

  rc_halt "beadm umount -f ${STAGEBE}"
}

mk_stage_be_default()
{
  # Rename the BE
  rc_halt "beadm rename $STAGEBE $newBEName"
  # Rename the nickname
  rc_halt "beadm activate $newBEName"

  # Only update grub if its installed
  if [ -e "/boot/grub/grub.cfg" ] ; then
    rc_halt "grub-mkconfig -o /boot/grub/grub.cfg"
  fi
}

do_auto_be()
{
  # User requested a new autobe to be created
  create_auto_beadm
}

touch_updateinprogress()
{
   if [ -e "/tmp/.rebootRequired" ] ; then
      if [ "`cat /tmp/.rebootRequired`" = "`who -b`" ] ; then
        exit_err "Waiting to reboot from previous update!"
      fi
   fi
   if [ -e "/tmp/.updateInProgress" ] ; then
      pgrep -F /tmp/.updateInProgress >/dev/null 2>/dev/null
      if [ $? -eq 0 ] ; then
        exit_err "Another update is in progress!"
      fi
   fi
   echo "$$" > /tmp/.updateInProgress
}

touch_reboot()
{
   rm /tmp/.updateInProgress
   who -b >  /tmp/.rebootRequired
   if [ -e "${NEWPKGLIST}" ] ; then
     cat ${NEWPKGLIST} >> /tmp/.rebootRequired
   fi
}

require_root()
{
  if [ `id -u` != "0" ] ; then exit_err "Must be run as root!" ; fi
  if [ ! -d "$STATEDIR" ] ; then
    mkdir -p $STATEDIR 2>/dev/null
  fi
}

rotate_log()
{
  if [ -e "$LOGOUT" ] ; then
     cp ${LOGOUT} ${LOGOUT}.prev
  fi
  if [ `id -u` = "0" ] ; then
    echo "pc-updatemanager: `date`" > $LOGOUT
  fi
}

run_update_pre()
{
  UPDATEDOTDPRE="${UPDATEDOTD}/pre"
  if [ ! -d "${UPDATEDOTDPRE}" ] ; then return 0; fi

  for pre in `ls ${UPDATEDOTDPRE}`
  do
    if [ "$pre" = "README" ] ; then continue ; fi

    echo "Running pre-update script: $pre"
    sh ${UPDATEDOTDPRE}/${pre} "$1"
    if [ $? -ne 0 ] ; then
       exit_err "Failed running pre-update script: $pre"
    fi
  done
}

run_update_post() {
  UPDATEDOTDPOST="${UPDATEDOTD}/post"
  if [ ! -d "${UPDATEDOTDPOST}" ] ; then return 0; fi

  for post in `ls ${UPDATEDOTDPOST}`
  do
    if [ "$post" = "README" ] ; then continue ; fi

    echo "Running post-update script: $post"
    sh ${UPDATEDOTDPOST}/${post} "$1"
    if [ $? -ne 0 ] ; then
       echo "WARNING: Failed running post-update script: $post"
    fi
  done
}

countdown()
{
        local SECONDS=$1
        local START=$(date +%s)
        local END=$(expr $START + $SECONDS)
        local CUR=$START

        while [ $CUR -lt $END ]
        do
                CUR=$(date +%s)
                LEFT=$(expr $END - $CUR)

                printf "\r%02d" \
                        $(expr $LEFT % 60)

                sleep 1
        done
        echo "        "
}

# Start the 2nd stage update
shutdown_update() {

  # Set the env vars
  TERM="cons25" ; export TERM
  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin" ; export PATH

  # Clear the screen
  clear

  sleep 2

  # Ask the user if they want to bail on this update
  echo "*****************************************************"
  echo "       A system update is ready to install."
  echo "        Press ENTER to cancel this update"
  echo "    The update can be installed at a later time"
  echo "*****************************************************"

  # Display the countdown
  #(countdown "10") &
  #CPID=$!

  # Look for the response
  #read -t 10 tmp
  #if [ $? -eq 0 ] ; then
    # User asked to bail, we will do so
  #  kill $CPID
  #  exit 0
  #fi
  #kill $CPID

  # Clear the screen
  clear

  # Get the type of update we are doing
  UPTYPE=$(cat ${STATEDIR}/shutdown-update-trigger)

  # Remove the update trigger, so we don't run on a 2nd shutdown
  # after a crash / hard power off
  rm ${STATEDIR}/shutdown-update-trigger

  # Let the GUI know we have started a shutdown
  touch ${STATEDIR}/.doingShutdownUpdate

  # Kill all desktop logins
  touch /tmp/.PCDMstop
  killall -9 pcdm-session
  killall -9 PCDM-session

  # Load State
  set_update_vars

  # Determine the tty to display details on
  if [ -e "/dev/ttyv1" ] ; then
    TTY="/dev/ttyv1"
    FKEY="(Alt-F2 for details)"
  elif [ -e "/dev/ttyv2" ] ; then
    TTY="/dev/ttyv2"
    FKEY="(Alt-F3 for details)"
  else
    TTY="/dev/null"
    FKEY=""
  fi

  # Unmount remote filesystems to prevent the update process from
  # hanging if the remote server goes down.
  umount -A -t nfs,smbfs,cifs

  # Display whats going on:
  echo "*****************************************************"
  echo "             Starting update process..."
  echo "      !! Please do NOT turn off the computer !!"
  echo " All logs are stored in /var/log/pc-updatemanager.log"
  echo "             ${FKEY}"
  echo "*****************************************************"

  case $UPTYPE in
update_pkgs_only) update_pkgs_only_stage2 >${TTY} 2>${TTY}
		  ;;
update_world_and_pkgs) update_world_and_pkgs_stage2 >${TTY} 2>${TTY}
                  ;;
    *) clear
       echo "Unknown update type: $UPTYPE"
       sleep 10
       exit 1
       ;;
  esac

  echo ""
  echo "*****************************************************"
  echo "                 Update Finished"
  echo "*****************************************************"
  exit 0
}

prep_update_shutdown() {
  echo "$1" > ${STATEDIR}/shutdown-update-trigger
  ACTIVE_UPDATE=$(sysrc -q -n trueos_active_update)
  if [ -n "$ACTIVE_UPDATE" ] ; then
    echo_log "Your update is staged and ready to install."
    echo_log "To reboot and begin the update run # pc-updatemanager startupdate"
    touch /tmp/.trueos-update-staged
    if [ -e "${NEWPKGLIST}" ] ; then
      cat ${NEWPKGLIST} >> /tmp/.trueos-update-staged
    fi
  else
    touch_reboot
    echo_log "Your update is ready to install. Please shutdown to finish the update process."
  fi
  exit 0
}

# Check if a value is a number
is_num()
{
  expr $1 + 1 2>/dev/null
  return $?
}

do_prune_be()
{
  # Check for number of BE's to keep
  MAXBE="5"
  VAL="`cat ${trueos_ETCCONF} 2>/dev/null | grep 'MAXBE: ' | sed 's|MAXBE: ||g'`"
  if [ -n "$VAL" ] ; then
     if [ $(is_num "$VAL") ] ; then
       MAXBE="$VAL"
     fi
  fi

  # Shrink MAXBE by one, so that when we add a new one, it matches the real MAXBE
  MAXBE=`expr $MAXBE - 1`
  if [ $MAXBE -lt 1 ] ; then
    MAXBE=1
  fi

  # Check if we need to prune any BEs
  echo "Pruning old boot-environments..."
  bList="`mktemp /tmp/.belist.XXXXXX`"
  beadm list > $bList 2>$bList
  snapList=`cat $bList | grep -e "^beforeUpdate" -e "default" -e "-up-" | awk '{print $1}'`
  snapCount=`cat $bList | grep -e "^beforeUpdate" -e "default" -e "-up-" | awk '{print $1}' | wc -l | awk '{print $1}'`

  if [ -z "$snapCount" ] ; then return ; fi

  # Check if this is forced removal of an old BE
  if [ "$1" = "force" ] ; then
     # If we only have 3 BE's, return, don't want to prune less than that
     if [ $snapCount -lt 3 ] ; then
        return;
     fi
     MAXBE=`expr $snapCount - 1`
  fi

  # If we have less BE than MAX, return
  if [ $snapCount -lt $MAXBE ] ; then return ; fi

  # Reverse the list
  for tmp in $snapList
  do
     rSnaps="$tmp $rSnaps"
  done

  # Do any pruning
  KEEP="$MAXBE"
  num=0
  for snap in $rSnaps
  do
     num=`expr $num + 1`
     # Make sure this BE isn't mounted or running
     cat $bList | grep "^$snap " | grep -q -e " N " -e " NR "  -e " /"
     if [ $? -eq 0 ] ; then continue ; fi

     if [ $num -gt $KEEP ] ; then
        # Remove this old BE
        echo "Removing Boot Environment: $snap"
        beadm destroy -F $snap >/dev/null 2>/dev/null
     fi
  done

  rm $bList
}

get_root_pool_free_space()
{
  local ROOTPOOL=`mount | grep 'on / ' | cut -d '/' -f 1`
  if [ -z "$ROOTPOOL" ] ; then return ; fi
  local freeSpace=`zpool list -Hp ${ROOTPOOL} | awk '{print $4}'`
  if [ ! $(is_num "$freeSpace") ] ; then return ; fi
  # Convert freespace to Kb
  freeSpace=`expr $freeSpace / 1024 2>/dev/null`
  echo "$freeSpace"
}

if [ "`id -u`" = "0" ] ; then
  # Make the installed directory for this version
  if [ ! -d "${INSDIR}/${SYSVER}" ] ; then mkdir -p ${INSDIR}/${SYSVER} ; fi

  # Make the ignore directory for this version
  if [ ! -d "${IGNDIR}/${SYSVER}" ] ; then mkdir -p ${IGNDIR}/${SYSVER} ; fi

  # Fix issue with IPFS files being located in ${HOME}/.ipfs and somebody running
  # with sudo
  export HOME="/root"
fi

if [ $# -eq 0 ] ; then
   show_usage
   exit 1
fi


while [ $# -gt 0 ] ; do

   case $1 in
	  autobe) require_root
		  do_auto_be ;;
	   check) sync_pkgconf
		  get_update_file
                  do_check
		  exit $?
		  break
                  ;;
        showeol)  get_update_file
                  do_eol_display
		  exit $?
		  break
		  ;;
        branches) require_root
		  get_update_file
                  list_branches ; break ;;
        chbranch) require_root
		  rotate_log
		  get_update_file
                  do_branch "${2}"
		  exit 0
                  break
                  ;;
	pkgcheck) checkup_pkgs
		  exit $?
                  break
                  ;;
	syncconf) require_root
		  sync_pkgconf ; break ;;
       confcheck) check_pkgconf ; break ;;
       pkgupdate) require_root
		  sync_pkgconf
		  rotate_log
		  if [ "$CDN_TYPE" = "IPFS" ] ; then
			update_world_and_pkgs "12-CURRENT"
		  else
			update_pkgs_only "$2"
		  fi
		  exit 0
                  break
                  ;;
     startupdate) if [ ! -e "/tmp/.trueos-update-staged" ] ; then
	            echo "No update staged. Please run ${0} pkgupdate first"
		    exit 1
		  fi
	          echo "Preparing to reboot and upgrade!"
		  touch_reboot
		  sleep 2
		  shutdown -r now
	          ;;
	 install) require_root
		  rotate_log
		  get_update_file
                  do_install "${2}"
		  exit 0
                  break
                  ;;
            cron) require_root
                  waittime=$(jot -r 1 1 3600)
                  sleep $waittime
                  get_update_file
                  do_check
                  checkup_pkgs ; break ;;
doshutdownupdate) require_root
		  shutdown_update
	          ;;
	*) show_usage ;;
   esac
   shift
done

exit 0
